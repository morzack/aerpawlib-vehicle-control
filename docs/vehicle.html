<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>aerpawlib.vehicle API documentation</title>
<meta name="description" content="Core logic surrounding the various `Vehicle`s available to aerpawlib user
scripts" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>aerpawlib.vehicle</code></h1>
</header>
<section id="section-intro">
<p>Core logic surrounding the various <code><a title="aerpawlib.vehicle.Vehicle" href="#aerpawlib.vehicle.Vehicle">Vehicle</a></code>s available to aerpawlib user
scripts</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Core logic surrounding the various `Vehicle`s available to aerpawlib user
scripts
&#34;&#34;&#34;
import asyncio
import dronekit
from pymavlink import mavutil
import time
from typing import Callable

from . import util

# time to wait when polling for dronekit vehicle state changes
_POLLING_DELAY = 0.01 # s

class Vehicle:
    &#34;&#34;&#34;
    Overarching &#34;generic vehicle&#34; type. Implements all functionality, excluding
    movement commands (which are *always* vehicle specific).
    &#34;&#34;&#34;
    _vehicle: dronekit.Vehicle
    _has_heartbeat: bool
    
    # function used by &#34;verb&#34; functions to check and see if the vehicle can be
    # commanded to move. should be set to a new closure by verb functions to
    # redefine functionality
    _ready_to_move: Callable[[object], bool]=lambda _: True

    # temp hack to allow for dynamically making the drone abortable or not
    # aborting is triggered by mode changes, so we need to ignore the initial
    # takeoff and final landing changes
    _abortable: bool=False
    _aborted: bool=False

    _home_location: util.Coordinate

    def __init__(self, connection_string: str):
        self._vehicle = dronekit.connect(connection_string, wait_ready=True)
        
        # TODO this is commented until the filter is made more permissive
        # or we find an alternative way of getting the autopilot&#39;s home location
        # self._vehicle.commands.download()
        # self._vehicle.commands.wait_ready() # we need to do this to capture
        #                                     # things such as the home location
        
        self._has_heartbeat = False
        
        # register required listeners after connecting
        def _heartbeat_listener(_, __, value):
            if value &gt; 1 and self._has_heartbeat:
                self._has_heartbeat = False
            elif value &lt; 1 and not self._has_heartbeat:
                self._has_heartbeat = True
        self._vehicle.add_attribute_listener(&#34;last_heartbeat&#34;, _heartbeat_listener)

        def _abort_listener(_, __, value):
            # TODO abort logic is more complicated :P
            # if value != &#34;GUIDED&#34;:
            #     self._abort()
            return
        self._vehicle.add_attribute_listener(&#34;mode&#34;, _abort_listener)

        # wait for connection
        while not self._has_heartbeat:
            time.sleep(_POLLING_DELAY)

    # nouns
    @property
    def connected(self) -&gt; bool:
        &#34;&#34;&#34;
        True if receiving heartbeats, False otherwise
        &#34;&#34;&#34;
        return self._has_heartbeat

    @property
    def position(self) -&gt; util.Coordinate:
        &#34;&#34;&#34;
        Get the current position of the Vehicle as a `util.Coordinate`
        &#34;&#34;&#34;
        loc = self._vehicle.location.global_relative_frame
        return util.Coordinate(loc.lat, loc.lon, loc.alt)

    @property
    def battery(self) -&gt; dronekit.Battery:
        &#34;&#34;&#34;
        Get the status of the battery. Wraps `dronekit.Battery`, which makes
        the `voltage`, `current`, and `level` available
        &#34;&#34;&#34;
        return self._vehicle.battery

    @property
    def gps(self) -&gt; dronekit.GPSInfo:
        &#34;&#34;&#34;
        Get the current GPS status (for gps_0 -- can be changed in the future).
        Wraps `dronekit.GPSInfo`, which exposes the `fix_type` (0-1: no fix,
        2: 2d fix, 3: 3d fix), and number of `satellites_visible`, among other
        things.
        &#34;&#34;&#34;
        return self._vehicle.gps_0

    @property
    def armed(self) -&gt; bool:
        return self._vehicle.armed

    @property
    def home_coords(self) -&gt; util.Coordinate:
        return self._home_location
    
    @property
    def heading(self) -&gt; float:
        return self._vehicle.heading
    
    # special things
    def done_moving(self) -&gt; bool:
        &#34;&#34;&#34;
        See if the vehicle is ready to move (i.e. if the last movement command
        has been completed). Also makes sure that the vehicle is connected and
        that we haven&#39;t aborted.
        
        This is more accurately a function that describes the vehicle&#39;s
        willingness to take a new command.
        &#34;&#34;&#34;
        if not self.connected or self._aborted:
            return False

        # syntax hack. functions and methods are different and need to be called
        # differently to prevent them from being bound to self
        if hasattr(self._ready_to_move, &#34;__func__&#34;):        # method
            return self._ready_to_move.__func__(self)
        return self._ready_to_move(self)                    # function
    
    async def await_ready_to_move(self):
        &#34;&#34;&#34;
        Helper function that blocks execution and waits for the vehicle to
        finish the current action/movement that it was instructed to do.

        Makes use of `Vehicle.done_moving`
        &#34;&#34;&#34;
        while not self.done_moving(): await asyncio.sleep(_POLLING_DELAY)

    def _abort(self):
        # TODO this should be something different in the future.
        # the intent of it in the past has been blocking further execution of
        # more vehicle control logic.
        if self._abortable:
            print(&#34;Aborted.&#34;)
            self._abortable = False
            self._aborted = True

    # verbs
    def close(self):
        &#34;&#34;&#34;
        Clean up the `Vehicle` object/any state
        &#34;&#34;&#34;
        self._vehicle.close()

    async def set_armed(self, value: bool):
        &#34;&#34;&#34;
        Arm or disarm this vehicle, and wait for it to be armed (if possible)

        Dronekit doesn&#39;t guarentee that the vehicle arms immediately (or at
        all!), so this will block execution until the vehicle has been armed.

        If the vehicle can&#39;t be armed, an Exception is raised.
        &#34;&#34;&#34;
        # dronekit doesn&#39;t guarentee that the vehicle arms immediately (or at all!)
        # this pattern keeps the funky logic out of the experimenter&#39;s script
        # to make sure that things are safer overall
        if not self._vehicle.is_armable:
            raise Exception(&#34;Not ready to arm&#34;) # in this case, the script dies completely
                                                # obviously not optimal *unless* we are
                                                # certain that a scipt always arms once
        self._vehicle.armed = value
        while not self._vehicle.armed: await asyncio.sleep(_POLLING_DELAY)

    def _initialize(self):
        &#34;&#34;&#34;
        Generic pre-mission manipulation of the vehicle into a state that is
        acceptable. MUST be called before anything else. Though this is done by
        the runner.
        &#34;&#34;&#34;
        while not self.armed: time.sleep(_POLLING_DELAY)

        self._vehicle.mode = dronekit.VehicleMode(&#34;GUIDED&#34;)
        self._abortable = True
        self._home_location = self.position
    
    async def goto_coordinates(self, coordinates: util.Coordinate, tolerance: float=2):
        &#34;&#34;&#34;
        Make the vehicle go to provided coordinates.

        `tolerance` is the min distance away from the coordinates, in meters,
        that is acceptable.

        This method is only available for vehicles built off the `Vehicle` type
        (ex: `Drone` or `Rover`)
        &#34;&#34;&#34;
        raise Exception(&#34;Generic vehicles can&#39;t go to coordinates!&#34;)

class Drone(Vehicle):
    &#34;&#34;&#34;
    Drone vehicle type. Implements all functionality that AERPAW&#39;s drones
    expose to user scripts, which includes basic movement control (going to
    coords, turning, landing).
    &#34;&#34;&#34;
    async def set_heading(self, heading: float):
        &#34;&#34;&#34;
        Set the heading of the vehicle (in absolute deg).
        
        To turn a relative # of degrees, you can do something like
        `set_heading(drone.pos + x)`

        NOTE that this function still needs to be tested kind of extensively.
        Ardupilot has a few internal states that control the heading, and when
        it&#39;s manually set via a CMD_CONDITION_YAW command over mavlink, it&#39;s
        possible for it to either be ignored, be accepted and then ignored, or
        be accepted, switch the drone&#39;s internal turning state to be manually
        controlled, and then be stuck that way (i.e. the drone won&#39;t auto-fly
        in a &#34;straight&#34; direction). Basically, be warned.
        &#34;&#34;&#34;
        await self.await_ready_to_move()

        heading %= 360
        
        # NOTE that the system and component below are derived from commands
        # observed in SITL. could be wrong, and it&#39;s kind of magic undocumnted stuff.
        # doing more research.
        msg = self._vehicle.message_factory.command_long_encode(
            1, 250,                                     # target system, component
            mavutil.mavlink.MAV_CMD_CONDITION_YAW,      # command
            0,                                          # confirmation
            heading,                                    # yaw angle in deg
            0,                                          # yaw speed in deg/s
            0,                                          # direction to turn in (-1: ccw, 1: cw)
            0,                                          # never turn relative to our current heading
            0, 0, 0                                     # unused
            )
        self._vehicle.send_mavlink(msg)
        
        def _pointed_at_heading(self) -&gt; bool:
            _TURN_TOLERANCE_DEG = 5
            turn_diff = min([abs(i) for i in [heading - self.heading, self.heading - (heading + 360)]])
            return turn_diff &lt;= _TURN_TOLERANCE_DEG
        self._ready_to_move = _pointed_at_heading

        while not _pointed_at_heading(self): await asyncio.sleep(_POLLING_DELAY)

    async def takeoff(self, target_alt: float, min_alt_tolerance: float=0.95):
        &#34;&#34;&#34;
        Make the drone take off to a specific altitude, and blocks until the
        drone has reached that altitude.

        Additionally waits to make sure that channel 4 of RCIN (used for yaw)
        is centered to avoid yaw during takeoff if the drone was *just* armed.
        &#34;&#34;&#34;
        await self.await_ready_to_move()        

        # TODO the below logic needs to be tested at the field (and likely made less brittle)
        # wait for sticks to return to center by taking rolling avg (30 frames)
        rcin_4 = [-999] * 30 # use something obviously out of range
        def _rcin_4_listener(_, __, message):
            rcin_4.pop(0)
            rcin_4.append(message.chan4_raw)
        self._vehicle.add_message_listener(&#34;RC_CHANNELS&#34;, _rcin_4_listener)
        while not 1450 &lt;= (sum(rcin_4) / len(rcin_4)) &lt;= 1550: await asyncio.sleep(_POLLING_DELAY)
        self._vehicle.remove_message_listener(&#34;RC_CHANNELS&#34;, _rcin_4_listener)
        
        self._vehicle.simple_takeoff(target_alt)
        
        taken_off = lambda self: self.position.alt &gt;= target_alt * min_alt_tolerance
        self._ready_to_move = taken_off

        while not taken_off(self): await asyncio.sleep(_POLLING_DELAY)

    async def land(self):
        &#34;&#34;&#34;
        Land the drone at its current position and block while waiting for it
        to be disarmed. No further movement is allowed after the drone has been
        landed (for now, may be changed later).
        &#34;&#34;&#34;
        await self.await_ready_to_move()

        self._abortable = False
        self._vehicle.mode = dronekit.VehicleMode(&#34;LAND&#34;)

        self._ready_to_move = lambda _: False
        while self.armed: await asyncio.sleep(_POLLING_DELAY)

    async def goto_coordinates(self, coordinates: util.Coordinate, tolerance: float=2):
        await self.await_ready_to_move()
        self._vehicle.simple_goto(coordinates.location())
        
        # TODO in the future we likely want to split alt into a different tolerance
        at_coords = lambda self: \
            coordinates.distance(self.position) &lt;= tolerance
        self._ready_to_move = at_coords

        while not at_coords(self): await asyncio.sleep(_POLLING_DELAY)

class Rover(Vehicle):
    &#34;&#34;&#34;
    Rover vehicle type. Implements all functionality that AERPAW&#39;s rovers
    expose to user scripts, which includes basic movement control (going to
    coords).
    &#34;&#34;&#34;
    async def goto_coordinates(self, coordinates: util.Coordinate, tolerance: float=2):
        await self.await_ready_to_move()
        self._vehicle.simple_goto(util.Coordinate(coordinates.lat, coordinates.lon, 0))
        
        at_coords = lambda self: \
            coordinates.ground_distance(self.position) &lt;= tolerance
        self._ready_to_move = at_coords

        while not at_coords(self): await asyncio.sleep(_POLLING_DELAY)

# TODO break this down further:
# class LAM(Drone)
# class SAM(Drone)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="aerpawlib.vehicle.Drone"><code class="flex name class">
<span>class <span class="ident">Drone</span></span>
<span>(</span><span>connection_string: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Drone vehicle type. Implements all functionality that AERPAW's drones
expose to user scripts, which includes basic movement control (going to
coords, turning, landing).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Drone(Vehicle):
    &#34;&#34;&#34;
    Drone vehicle type. Implements all functionality that AERPAW&#39;s drones
    expose to user scripts, which includes basic movement control (going to
    coords, turning, landing).
    &#34;&#34;&#34;
    async def set_heading(self, heading: float):
        &#34;&#34;&#34;
        Set the heading of the vehicle (in absolute deg).
        
        To turn a relative # of degrees, you can do something like
        `set_heading(drone.pos + x)`

        NOTE that this function still needs to be tested kind of extensively.
        Ardupilot has a few internal states that control the heading, and when
        it&#39;s manually set via a CMD_CONDITION_YAW command over mavlink, it&#39;s
        possible for it to either be ignored, be accepted and then ignored, or
        be accepted, switch the drone&#39;s internal turning state to be manually
        controlled, and then be stuck that way (i.e. the drone won&#39;t auto-fly
        in a &#34;straight&#34; direction). Basically, be warned.
        &#34;&#34;&#34;
        await self.await_ready_to_move()

        heading %= 360
        
        # NOTE that the system and component below are derived from commands
        # observed in SITL. could be wrong, and it&#39;s kind of magic undocumnted stuff.
        # doing more research.
        msg = self._vehicle.message_factory.command_long_encode(
            1, 250,                                     # target system, component
            mavutil.mavlink.MAV_CMD_CONDITION_YAW,      # command
            0,                                          # confirmation
            heading,                                    # yaw angle in deg
            0,                                          # yaw speed in deg/s
            0,                                          # direction to turn in (-1: ccw, 1: cw)
            0,                                          # never turn relative to our current heading
            0, 0, 0                                     # unused
            )
        self._vehicle.send_mavlink(msg)
        
        def _pointed_at_heading(self) -&gt; bool:
            _TURN_TOLERANCE_DEG = 5
            turn_diff = min([abs(i) for i in [heading - self.heading, self.heading - (heading + 360)]])
            return turn_diff &lt;= _TURN_TOLERANCE_DEG
        self._ready_to_move = _pointed_at_heading

        while not _pointed_at_heading(self): await asyncio.sleep(_POLLING_DELAY)

    async def takeoff(self, target_alt: float, min_alt_tolerance: float=0.95):
        &#34;&#34;&#34;
        Make the drone take off to a specific altitude, and blocks until the
        drone has reached that altitude.

        Additionally waits to make sure that channel 4 of RCIN (used for yaw)
        is centered to avoid yaw during takeoff if the drone was *just* armed.
        &#34;&#34;&#34;
        await self.await_ready_to_move()        

        # TODO the below logic needs to be tested at the field (and likely made less brittle)
        # wait for sticks to return to center by taking rolling avg (30 frames)
        rcin_4 = [-999] * 30 # use something obviously out of range
        def _rcin_4_listener(_, __, message):
            rcin_4.pop(0)
            rcin_4.append(message.chan4_raw)
        self._vehicle.add_message_listener(&#34;RC_CHANNELS&#34;, _rcin_4_listener)
        while not 1450 &lt;= (sum(rcin_4) / len(rcin_4)) &lt;= 1550: await asyncio.sleep(_POLLING_DELAY)
        self._vehicle.remove_message_listener(&#34;RC_CHANNELS&#34;, _rcin_4_listener)
        
        self._vehicle.simple_takeoff(target_alt)
        
        taken_off = lambda self: self.position.alt &gt;= target_alt * min_alt_tolerance
        self._ready_to_move = taken_off

        while not taken_off(self): await asyncio.sleep(_POLLING_DELAY)

    async def land(self):
        &#34;&#34;&#34;
        Land the drone at its current position and block while waiting for it
        to be disarmed. No further movement is allowed after the drone has been
        landed (for now, may be changed later).
        &#34;&#34;&#34;
        await self.await_ready_to_move()

        self._abortable = False
        self._vehicle.mode = dronekit.VehicleMode(&#34;LAND&#34;)

        self._ready_to_move = lambda _: False
        while self.armed: await asyncio.sleep(_POLLING_DELAY)

    async def goto_coordinates(self, coordinates: util.Coordinate, tolerance: float=2):
        await self.await_ready_to_move()
        self._vehicle.simple_goto(coordinates.location())
        
        # TODO in the future we likely want to split alt into a different tolerance
        at_coords = lambda self: \
            coordinates.distance(self.position) &lt;= tolerance
        self._ready_to_move = at_coords

        while not at_coords(self): await asyncio.sleep(_POLLING_DELAY)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="aerpawlib.vehicle.Vehicle" href="#aerpawlib.vehicle.Vehicle">Vehicle</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="aerpawlib.vehicle.Drone.land"><code class="name flex">
<span>async def <span class="ident">land</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Land the drone at its current position and block while waiting for it
to be disarmed. No further movement is allowed after the drone has been
landed (for now, may be changed later).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def land(self):
    &#34;&#34;&#34;
    Land the drone at its current position and block while waiting for it
    to be disarmed. No further movement is allowed after the drone has been
    landed (for now, may be changed later).
    &#34;&#34;&#34;
    await self.await_ready_to_move()

    self._abortable = False
    self._vehicle.mode = dronekit.VehicleMode(&#34;LAND&#34;)

    self._ready_to_move = lambda _: False
    while self.armed: await asyncio.sleep(_POLLING_DELAY)</code></pre>
</details>
</dd>
<dt id="aerpawlib.vehicle.Drone.set_heading"><code class="name flex">
<span>async def <span class="ident">set_heading</span></span>(<span>self, heading: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the heading of the vehicle (in absolute deg).</p>
<p>To turn a relative # of degrees, you can do something like
<code>set_heading(drone.pos + x)</code></p>
<p>NOTE that this function still needs to be tested kind of extensively.
Ardupilot has a few internal states that control the heading, and when
it's manually set via a CMD_CONDITION_YAW command over mavlink, it's
possible for it to either be ignored, be accepted and then ignored, or
be accepted, switch the drone's internal turning state to be manually
controlled, and then be stuck that way (i.e. the drone won't auto-fly
in a "straight" direction). Basically, be warned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_heading(self, heading: float):
    &#34;&#34;&#34;
    Set the heading of the vehicle (in absolute deg).
    
    To turn a relative # of degrees, you can do something like
    `set_heading(drone.pos + x)`

    NOTE that this function still needs to be tested kind of extensively.
    Ardupilot has a few internal states that control the heading, and when
    it&#39;s manually set via a CMD_CONDITION_YAW command over mavlink, it&#39;s
    possible for it to either be ignored, be accepted and then ignored, or
    be accepted, switch the drone&#39;s internal turning state to be manually
    controlled, and then be stuck that way (i.e. the drone won&#39;t auto-fly
    in a &#34;straight&#34; direction). Basically, be warned.
    &#34;&#34;&#34;
    await self.await_ready_to_move()

    heading %= 360
    
    # NOTE that the system and component below are derived from commands
    # observed in SITL. could be wrong, and it&#39;s kind of magic undocumnted stuff.
    # doing more research.
    msg = self._vehicle.message_factory.command_long_encode(
        1, 250,                                     # target system, component
        mavutil.mavlink.MAV_CMD_CONDITION_YAW,      # command
        0,                                          # confirmation
        heading,                                    # yaw angle in deg
        0,                                          # yaw speed in deg/s
        0,                                          # direction to turn in (-1: ccw, 1: cw)
        0,                                          # never turn relative to our current heading
        0, 0, 0                                     # unused
        )
    self._vehicle.send_mavlink(msg)
    
    def _pointed_at_heading(self) -&gt; bool:
        _TURN_TOLERANCE_DEG = 5
        turn_diff = min([abs(i) for i in [heading - self.heading, self.heading - (heading + 360)]])
        return turn_diff &lt;= _TURN_TOLERANCE_DEG
    self._ready_to_move = _pointed_at_heading

    while not _pointed_at_heading(self): await asyncio.sleep(_POLLING_DELAY)</code></pre>
</details>
</dd>
<dt id="aerpawlib.vehicle.Drone.takeoff"><code class="name flex">
<span>async def <span class="ident">takeoff</span></span>(<span>self, target_alt: float, min_alt_tolerance: float = 0.95)</span>
</code></dt>
<dd>
<div class="desc"><p>Make the drone take off to a specific altitude, and blocks until the
drone has reached that altitude.</p>
<p>Additionally waits to make sure that channel 4 of RCIN (used for yaw)
is centered to avoid yaw during takeoff if the drone was <em>just</em> armed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def takeoff(self, target_alt: float, min_alt_tolerance: float=0.95):
    &#34;&#34;&#34;
    Make the drone take off to a specific altitude, and blocks until the
    drone has reached that altitude.

    Additionally waits to make sure that channel 4 of RCIN (used for yaw)
    is centered to avoid yaw during takeoff if the drone was *just* armed.
    &#34;&#34;&#34;
    await self.await_ready_to_move()        

    # TODO the below logic needs to be tested at the field (and likely made less brittle)
    # wait for sticks to return to center by taking rolling avg (30 frames)
    rcin_4 = [-999] * 30 # use something obviously out of range
    def _rcin_4_listener(_, __, message):
        rcin_4.pop(0)
        rcin_4.append(message.chan4_raw)
    self._vehicle.add_message_listener(&#34;RC_CHANNELS&#34;, _rcin_4_listener)
    while not 1450 &lt;= (sum(rcin_4) / len(rcin_4)) &lt;= 1550: await asyncio.sleep(_POLLING_DELAY)
    self._vehicle.remove_message_listener(&#34;RC_CHANNELS&#34;, _rcin_4_listener)
    
    self._vehicle.simple_takeoff(target_alt)
    
    taken_off = lambda self: self.position.alt &gt;= target_alt * min_alt_tolerance
    self._ready_to_move = taken_off

    while not taken_off(self): await asyncio.sleep(_POLLING_DELAY)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="aerpawlib.vehicle.Vehicle" href="#aerpawlib.vehicle.Vehicle">Vehicle</a></b></code>:
<ul class="hlist">
<li><code><a title="aerpawlib.vehicle.Vehicle.await_ready_to_move" href="#aerpawlib.vehicle.Vehicle.await_ready_to_move">await_ready_to_move</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.battery" href="#aerpawlib.vehicle.Vehicle.battery">battery</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.close" href="#aerpawlib.vehicle.Vehicle.close">close</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.connected" href="#aerpawlib.vehicle.Vehicle.connected">connected</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.done_moving" href="#aerpawlib.vehicle.Vehicle.done_moving">done_moving</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.goto_coordinates" href="#aerpawlib.vehicle.Vehicle.goto_coordinates">goto_coordinates</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.gps" href="#aerpawlib.vehicle.Vehicle.gps">gps</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.position" href="#aerpawlib.vehicle.Vehicle.position">position</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.set_armed" href="#aerpawlib.vehicle.Vehicle.set_armed">set_armed</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="aerpawlib.vehicle.Rover"><code class="flex name class">
<span>class <span class="ident">Rover</span></span>
<span>(</span><span>connection_string: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Rover vehicle type. Implements all functionality that AERPAW's rovers
expose to user scripts, which includes basic movement control (going to
coords).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rover(Vehicle):
    &#34;&#34;&#34;
    Rover vehicle type. Implements all functionality that AERPAW&#39;s rovers
    expose to user scripts, which includes basic movement control (going to
    coords).
    &#34;&#34;&#34;
    async def goto_coordinates(self, coordinates: util.Coordinate, tolerance: float=2):
        await self.await_ready_to_move()
        self._vehicle.simple_goto(util.Coordinate(coordinates.lat, coordinates.lon, 0))
        
        at_coords = lambda self: \
            coordinates.ground_distance(self.position) &lt;= tolerance
        self._ready_to_move = at_coords

        while not at_coords(self): await asyncio.sleep(_POLLING_DELAY)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="aerpawlib.vehicle.Vehicle" href="#aerpawlib.vehicle.Vehicle">Vehicle</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="aerpawlib.vehicle.Vehicle" href="#aerpawlib.vehicle.Vehicle">Vehicle</a></b></code>:
<ul class="hlist">
<li><code><a title="aerpawlib.vehicle.Vehicle.await_ready_to_move" href="#aerpawlib.vehicle.Vehicle.await_ready_to_move">await_ready_to_move</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.battery" href="#aerpawlib.vehicle.Vehicle.battery">battery</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.close" href="#aerpawlib.vehicle.Vehicle.close">close</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.connected" href="#aerpawlib.vehicle.Vehicle.connected">connected</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.done_moving" href="#aerpawlib.vehicle.Vehicle.done_moving">done_moving</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.goto_coordinates" href="#aerpawlib.vehicle.Vehicle.goto_coordinates">goto_coordinates</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.gps" href="#aerpawlib.vehicle.Vehicle.gps">gps</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.position" href="#aerpawlib.vehicle.Vehicle.position">position</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.set_armed" href="#aerpawlib.vehicle.Vehicle.set_armed">set_armed</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="aerpawlib.vehicle.Vehicle"><code class="flex name class">
<span>class <span class="ident">Vehicle</span></span>
<span>(</span><span>connection_string: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Overarching "generic vehicle" type. Implements all functionality, excluding
movement commands (which are <em>always</em> vehicle specific).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Vehicle:
    &#34;&#34;&#34;
    Overarching &#34;generic vehicle&#34; type. Implements all functionality, excluding
    movement commands (which are *always* vehicle specific).
    &#34;&#34;&#34;
    _vehicle: dronekit.Vehicle
    _has_heartbeat: bool
    
    # function used by &#34;verb&#34; functions to check and see if the vehicle can be
    # commanded to move. should be set to a new closure by verb functions to
    # redefine functionality
    _ready_to_move: Callable[[object], bool]=lambda _: True

    # temp hack to allow for dynamically making the drone abortable or not
    # aborting is triggered by mode changes, so we need to ignore the initial
    # takeoff and final landing changes
    _abortable: bool=False
    _aborted: bool=False

    _home_location: util.Coordinate

    def __init__(self, connection_string: str):
        self._vehicle = dronekit.connect(connection_string, wait_ready=True)
        
        # TODO this is commented until the filter is made more permissive
        # or we find an alternative way of getting the autopilot&#39;s home location
        # self._vehicle.commands.download()
        # self._vehicle.commands.wait_ready() # we need to do this to capture
        #                                     # things such as the home location
        
        self._has_heartbeat = False
        
        # register required listeners after connecting
        def _heartbeat_listener(_, __, value):
            if value &gt; 1 and self._has_heartbeat:
                self._has_heartbeat = False
            elif value &lt; 1 and not self._has_heartbeat:
                self._has_heartbeat = True
        self._vehicle.add_attribute_listener(&#34;last_heartbeat&#34;, _heartbeat_listener)

        def _abort_listener(_, __, value):
            # TODO abort logic is more complicated :P
            # if value != &#34;GUIDED&#34;:
            #     self._abort()
            return
        self._vehicle.add_attribute_listener(&#34;mode&#34;, _abort_listener)

        # wait for connection
        while not self._has_heartbeat:
            time.sleep(_POLLING_DELAY)

    # nouns
    @property
    def connected(self) -&gt; bool:
        &#34;&#34;&#34;
        True if receiving heartbeats, False otherwise
        &#34;&#34;&#34;
        return self._has_heartbeat

    @property
    def position(self) -&gt; util.Coordinate:
        &#34;&#34;&#34;
        Get the current position of the Vehicle as a `util.Coordinate`
        &#34;&#34;&#34;
        loc = self._vehicle.location.global_relative_frame
        return util.Coordinate(loc.lat, loc.lon, loc.alt)

    @property
    def battery(self) -&gt; dronekit.Battery:
        &#34;&#34;&#34;
        Get the status of the battery. Wraps `dronekit.Battery`, which makes
        the `voltage`, `current`, and `level` available
        &#34;&#34;&#34;
        return self._vehicle.battery

    @property
    def gps(self) -&gt; dronekit.GPSInfo:
        &#34;&#34;&#34;
        Get the current GPS status (for gps_0 -- can be changed in the future).
        Wraps `dronekit.GPSInfo`, which exposes the `fix_type` (0-1: no fix,
        2: 2d fix, 3: 3d fix), and number of `satellites_visible`, among other
        things.
        &#34;&#34;&#34;
        return self._vehicle.gps_0

    @property
    def armed(self) -&gt; bool:
        return self._vehicle.armed

    @property
    def home_coords(self) -&gt; util.Coordinate:
        return self._home_location
    
    @property
    def heading(self) -&gt; float:
        return self._vehicle.heading
    
    # special things
    def done_moving(self) -&gt; bool:
        &#34;&#34;&#34;
        See if the vehicle is ready to move (i.e. if the last movement command
        has been completed). Also makes sure that the vehicle is connected and
        that we haven&#39;t aborted.
        
        This is more accurately a function that describes the vehicle&#39;s
        willingness to take a new command.
        &#34;&#34;&#34;
        if not self.connected or self._aborted:
            return False

        # syntax hack. functions and methods are different and need to be called
        # differently to prevent them from being bound to self
        if hasattr(self._ready_to_move, &#34;__func__&#34;):        # method
            return self._ready_to_move.__func__(self)
        return self._ready_to_move(self)                    # function
    
    async def await_ready_to_move(self):
        &#34;&#34;&#34;
        Helper function that blocks execution and waits for the vehicle to
        finish the current action/movement that it was instructed to do.

        Makes use of `Vehicle.done_moving`
        &#34;&#34;&#34;
        while not self.done_moving(): await asyncio.sleep(_POLLING_DELAY)

    def _abort(self):
        # TODO this should be something different in the future.
        # the intent of it in the past has been blocking further execution of
        # more vehicle control logic.
        if self._abortable:
            print(&#34;Aborted.&#34;)
            self._abortable = False
            self._aborted = True

    # verbs
    def close(self):
        &#34;&#34;&#34;
        Clean up the `Vehicle` object/any state
        &#34;&#34;&#34;
        self._vehicle.close()

    async def set_armed(self, value: bool):
        &#34;&#34;&#34;
        Arm or disarm this vehicle, and wait for it to be armed (if possible)

        Dronekit doesn&#39;t guarentee that the vehicle arms immediately (or at
        all!), so this will block execution until the vehicle has been armed.

        If the vehicle can&#39;t be armed, an Exception is raised.
        &#34;&#34;&#34;
        # dronekit doesn&#39;t guarentee that the vehicle arms immediately (or at all!)
        # this pattern keeps the funky logic out of the experimenter&#39;s script
        # to make sure that things are safer overall
        if not self._vehicle.is_armable:
            raise Exception(&#34;Not ready to arm&#34;) # in this case, the script dies completely
                                                # obviously not optimal *unless* we are
                                                # certain that a scipt always arms once
        self._vehicle.armed = value
        while not self._vehicle.armed: await asyncio.sleep(_POLLING_DELAY)

    def _initialize(self):
        &#34;&#34;&#34;
        Generic pre-mission manipulation of the vehicle into a state that is
        acceptable. MUST be called before anything else. Though this is done by
        the runner.
        &#34;&#34;&#34;
        while not self.armed: time.sleep(_POLLING_DELAY)

        self._vehicle.mode = dronekit.VehicleMode(&#34;GUIDED&#34;)
        self._abortable = True
        self._home_location = self.position
    
    async def goto_coordinates(self, coordinates: util.Coordinate, tolerance: float=2):
        &#34;&#34;&#34;
        Make the vehicle go to provided coordinates.

        `tolerance` is the min distance away from the coordinates, in meters,
        that is acceptable.

        This method is only available for vehicles built off the `Vehicle` type
        (ex: `Drone` or `Rover`)
        &#34;&#34;&#34;
        raise Exception(&#34;Generic vehicles can&#39;t go to coordinates!&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="aerpawlib.vehicle.Drone" href="#aerpawlib.vehicle.Drone">Drone</a></li>
<li><a title="aerpawlib.vehicle.Rover" href="#aerpawlib.vehicle.Rover">Rover</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="aerpawlib.vehicle.Vehicle.armed"><code class="name">var <span class="ident">armed</span> : bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def armed(self) -&gt; bool:
    return self._vehicle.armed</code></pre>
</details>
</dd>
<dt id="aerpawlib.vehicle.Vehicle.battery"><code class="name">var <span class="ident">battery</span> : dronekit.Battery</code></dt>
<dd>
<div class="desc"><p>Get the status of the battery. Wraps <code>dronekit.Battery</code>, which makes
the <code>voltage</code>, <code>current</code>, and <code>level</code> available</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def battery(self) -&gt; dronekit.Battery:
    &#34;&#34;&#34;
    Get the status of the battery. Wraps `dronekit.Battery`, which makes
    the `voltage`, `current`, and `level` available
    &#34;&#34;&#34;
    return self._vehicle.battery</code></pre>
</details>
</dd>
<dt id="aerpawlib.vehicle.Vehicle.connected"><code class="name">var <span class="ident">connected</span> : bool</code></dt>
<dd>
<div class="desc"><p>True if receiving heartbeats, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connected(self) -&gt; bool:
    &#34;&#34;&#34;
    True if receiving heartbeats, False otherwise
    &#34;&#34;&#34;
    return self._has_heartbeat</code></pre>
</details>
</dd>
<dt id="aerpawlib.vehicle.Vehicle.gps"><code class="name">var <span class="ident">gps</span> : dronekit.GPSInfo</code></dt>
<dd>
<div class="desc"><p>Get the current GPS status (for gps_0 &ndash; can be changed in the future).
Wraps <code>dronekit.GPSInfo</code>, which exposes the <code>fix_type</code> (0-1: no fix,
2: 2d fix, 3: 3d fix), and number of <code>satellites_visible</code>, among other
things.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gps(self) -&gt; dronekit.GPSInfo:
    &#34;&#34;&#34;
    Get the current GPS status (for gps_0 -- can be changed in the future).
    Wraps `dronekit.GPSInfo`, which exposes the `fix_type` (0-1: no fix,
    2: 2d fix, 3: 3d fix), and number of `satellites_visible`, among other
    things.
    &#34;&#34;&#34;
    return self._vehicle.gps_0</code></pre>
</details>
</dd>
<dt id="aerpawlib.vehicle.Vehicle.heading"><code class="name">var <span class="ident">heading</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def heading(self) -&gt; float:
    return self._vehicle.heading</code></pre>
</details>
</dd>
<dt id="aerpawlib.vehicle.Vehicle.home_coords"><code class="name">var <span class="ident">home_coords</span> : <a title="aerpawlib.util.Coordinate" href="util.html#aerpawlib.util.Coordinate">Coordinate</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def home_coords(self) -&gt; util.Coordinate:
    return self._home_location</code></pre>
</details>
</dd>
<dt id="aerpawlib.vehicle.Vehicle.position"><code class="name">var <span class="ident">position</span> : <a title="aerpawlib.util.Coordinate" href="util.html#aerpawlib.util.Coordinate">Coordinate</a></code></dt>
<dd>
<div class="desc"><p>Get the current position of the Vehicle as a <code>util.Coordinate</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def position(self) -&gt; util.Coordinate:
    &#34;&#34;&#34;
    Get the current position of the Vehicle as a `util.Coordinate`
    &#34;&#34;&#34;
    loc = self._vehicle.location.global_relative_frame
    return util.Coordinate(loc.lat, loc.lon, loc.alt)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="aerpawlib.vehicle.Vehicle.await_ready_to_move"><code class="name flex">
<span>async def <span class="ident">await_ready_to_move</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function that blocks execution and waits for the vehicle to
finish the current action/movement that it was instructed to do.</p>
<p>Makes use of <code><a title="aerpawlib.vehicle.Vehicle.done_moving" href="#aerpawlib.vehicle.Vehicle.done_moving">Vehicle.done_moving()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def await_ready_to_move(self):
    &#34;&#34;&#34;
    Helper function that blocks execution and waits for the vehicle to
    finish the current action/movement that it was instructed to do.

    Makes use of `Vehicle.done_moving`
    &#34;&#34;&#34;
    while not self.done_moving(): await asyncio.sleep(_POLLING_DELAY)</code></pre>
</details>
</dd>
<dt id="aerpawlib.vehicle.Vehicle.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clean up the <code><a title="aerpawlib.vehicle.Vehicle" href="#aerpawlib.vehicle.Vehicle">Vehicle</a></code> object/any state</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;
    Clean up the `Vehicle` object/any state
    &#34;&#34;&#34;
    self._vehicle.close()</code></pre>
</details>
</dd>
<dt id="aerpawlib.vehicle.Vehicle.done_moving"><code class="name flex">
<span>def <span class="ident">done_moving</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>See if the vehicle is ready to move (i.e. if the last movement command
has been completed). Also makes sure that the vehicle is connected and
that we haven't aborted.</p>
<p>This is more accurately a function that describes the vehicle's
willingness to take a new command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def done_moving(self) -&gt; bool:
    &#34;&#34;&#34;
    See if the vehicle is ready to move (i.e. if the last movement command
    has been completed). Also makes sure that the vehicle is connected and
    that we haven&#39;t aborted.
    
    This is more accurately a function that describes the vehicle&#39;s
    willingness to take a new command.
    &#34;&#34;&#34;
    if not self.connected or self._aborted:
        return False

    # syntax hack. functions and methods are different and need to be called
    # differently to prevent them from being bound to self
    if hasattr(self._ready_to_move, &#34;__func__&#34;):        # method
        return self._ready_to_move.__func__(self)
    return self._ready_to_move(self)                    # function</code></pre>
</details>
</dd>
<dt id="aerpawlib.vehicle.Vehicle.goto_coordinates"><code class="name flex">
<span>async def <span class="ident">goto_coordinates</span></span>(<span>self, coordinates: <a title="aerpawlib.util.Coordinate" href="util.html#aerpawlib.util.Coordinate">Coordinate</a>, tolerance: float = 2)</span>
</code></dt>
<dd>
<div class="desc"><p>Make the vehicle go to provided coordinates.</p>
<p><code>tolerance</code> is the min distance away from the coordinates, in meters,
that is acceptable.</p>
<p>This method is only available for vehicles built off the <code><a title="aerpawlib.vehicle.Vehicle" href="#aerpawlib.vehicle.Vehicle">Vehicle</a></code> type
(ex: <code><a title="aerpawlib.vehicle.Drone" href="#aerpawlib.vehicle.Drone">Drone</a></code> or <code><a title="aerpawlib.vehicle.Rover" href="#aerpawlib.vehicle.Rover">Rover</a></code>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def goto_coordinates(self, coordinates: util.Coordinate, tolerance: float=2):
    &#34;&#34;&#34;
    Make the vehicle go to provided coordinates.

    `tolerance` is the min distance away from the coordinates, in meters,
    that is acceptable.

    This method is only available for vehicles built off the `Vehicle` type
    (ex: `Drone` or `Rover`)
    &#34;&#34;&#34;
    raise Exception(&#34;Generic vehicles can&#39;t go to coordinates!&#34;)</code></pre>
</details>
</dd>
<dt id="aerpawlib.vehicle.Vehicle.set_armed"><code class="name flex">
<span>async def <span class="ident">set_armed</span></span>(<span>self, value: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Arm or disarm this vehicle, and wait for it to be armed (if possible)</p>
<p>Dronekit doesn't guarentee that the vehicle arms immediately (or at
all!), so this will block execution until the vehicle has been armed.</p>
<p>If the vehicle can't be armed, an Exception is raised.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_armed(self, value: bool):
    &#34;&#34;&#34;
    Arm or disarm this vehicle, and wait for it to be armed (if possible)

    Dronekit doesn&#39;t guarentee that the vehicle arms immediately (or at
    all!), so this will block execution until the vehicle has been armed.

    If the vehicle can&#39;t be armed, an Exception is raised.
    &#34;&#34;&#34;
    # dronekit doesn&#39;t guarentee that the vehicle arms immediately (or at all!)
    # this pattern keeps the funky logic out of the experimenter&#39;s script
    # to make sure that things are safer overall
    if not self._vehicle.is_armable:
        raise Exception(&#34;Not ready to arm&#34;) # in this case, the script dies completely
                                            # obviously not optimal *unless* we are
                                            # certain that a scipt always arms once
    self._vehicle.armed = value
    while not self._vehicle.armed: await asyncio.sleep(_POLLING_DELAY)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="aerpawlib" href="index.html">aerpawlib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="aerpawlib.vehicle.Drone" href="#aerpawlib.vehicle.Drone">Drone</a></code></h4>
<ul class="">
<li><code><a title="aerpawlib.vehicle.Drone.land" href="#aerpawlib.vehicle.Drone.land">land</a></code></li>
<li><code><a title="aerpawlib.vehicle.Drone.set_heading" href="#aerpawlib.vehicle.Drone.set_heading">set_heading</a></code></li>
<li><code><a title="aerpawlib.vehicle.Drone.takeoff" href="#aerpawlib.vehicle.Drone.takeoff">takeoff</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aerpawlib.vehicle.Rover" href="#aerpawlib.vehicle.Rover">Rover</a></code></h4>
</li>
<li>
<h4><code><a title="aerpawlib.vehicle.Vehicle" href="#aerpawlib.vehicle.Vehicle">Vehicle</a></code></h4>
<ul class="two-column">
<li><code><a title="aerpawlib.vehicle.Vehicle.armed" href="#aerpawlib.vehicle.Vehicle.armed">armed</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.await_ready_to_move" href="#aerpawlib.vehicle.Vehicle.await_ready_to_move">await_ready_to_move</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.battery" href="#aerpawlib.vehicle.Vehicle.battery">battery</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.close" href="#aerpawlib.vehicle.Vehicle.close">close</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.connected" href="#aerpawlib.vehicle.Vehicle.connected">connected</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.done_moving" href="#aerpawlib.vehicle.Vehicle.done_moving">done_moving</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.goto_coordinates" href="#aerpawlib.vehicle.Vehicle.goto_coordinates">goto_coordinates</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.gps" href="#aerpawlib.vehicle.Vehicle.gps">gps</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.heading" href="#aerpawlib.vehicle.Vehicle.heading">heading</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.home_coords" href="#aerpawlib.vehicle.Vehicle.home_coords">home_coords</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.position" href="#aerpawlib.vehicle.Vehicle.position">position</a></code></li>
<li><code><a title="aerpawlib.vehicle.Vehicle.set_armed" href="#aerpawlib.vehicle.Vehicle.set_armed">set_armed</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>