<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>aerpawlib.util API documentation</title>
<meta name="description" content="Types and functions commonly used throughout the aerpawlib framework." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>aerpawlib.util</code></h1>
</header>
<section id="section-intro">
<p>Types and functions commonly used throughout the aerpawlib framework.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Types and functions commonly used throughout the aerpawlib framework.
&#34;&#34;&#34;
import json
import math
from typing import List, Tuple
import dronekit

class VectorNED:
    &#34;&#34;&#34;
    Representation of a difference between two coordinates (used for expressing
    relative motion). Makes use of NED (north, east, down) scheme.

    Units are expressed in meters

    NOTE: Something similar to this may or may not be adopted into dronkit at
    some point in the future. There are plans on their GH page, at least.
    &#34;&#34;&#34;

    north: float
    east: float
    down: float

    def __init__(self, north: float, east: float, down: float=0):
        self.north = north
        self.east = east
        self.down = down

    def rotate_by_angle(self, angle: float):
        &#34;&#34;&#34;
        Transform this VectorNED and rotate it by a certain angle, provided in
        degrees.

        ex: VectorNED(1, 0, 0).rotate_by_angle(90) -&gt; VectorNed(0, -1, 0)
        ex: VectorNED(1, 0, 0).rotate_by_angle(45) -&gt; VectorNed(0.707, -0.707, 0)
        &#34;&#34;&#34;
        rads = angle / 180 * math.pi
        
        east = self.east * math.cos(rads) - self.north * math.sin(rads)
        north = self.east * math.sin(rads) + self.north * math.cos(rads)
        
        return VectorNED(north, east, self.down)

    def cross_product(self, o):
        &#34;&#34;&#34;
        find the cross product of this and the other vector (this x o)
        &#34;&#34;&#34;
        if not isinstance(o, VectorNED):
            raise TypeError()
        return VectorNED(
                self.east * o.down + self.down * o.east,
                self.down * o.north - self.north * o.down,
                self.north * o.east - self.east * o.north
                )

    def hypot(self, ignore_down: bool=False):
        &#34;&#34;&#34;
        find the distance of this VectorNED, optionally ignoring any changes in
        height
        &#34;&#34;&#34;
        if ignore_down:
            return math.hypot(self.north, self.east)
        else:
            return math.hypot(self.north, self.east, self.down)

    def __add__(self, o):
        if not isinstance(o, VectorNED):
            raise TypeError()
        return VectorNED(self.north + o.north,
                self.east + o.east,
                self.down + o.down)

    def __sub__(self, o):
        if not isinstance(o, VectorNED):
            raise TypeError()
        return VectorNED(self.north - o.north,
                self.east - o.east,
                self.down - o.down)
class Coordinate:
    &#34;&#34;&#34;
    An absolute point in space making use of lat, lon, and an altitude (over
    the home location of the vehicle). This is more or less equivalent to
    `dronekit.LocationGlobalRelative`, with more functionality added to support
    `VectorNED`s.

    Reference for the *implementations* of most of these functions can be found
    in the dronekit source or under some of their more specific examples.
    Searching for the constants is a pretty good way of finding them.

    `lat`/`lon` should be expressed in *degrees*, while `alt` is in *meters*
    (relative to the takeoff/home location)

    `Coordinate`s can be added or subtracted with `VectorNED`s using Python&#39;s
    respective operators to calculate a new `Coordinate` relative to the
    original. This is particularly useful if you want to implement relative
    movement.

    `Coordinate`s can be subtracted from each other using Python&#39;s subtraction
    operator to calculate the vector difference between them, which is returned
    as a `VectorNED`
    &#34;&#34;&#34;

    lat: float
    lon: float
    alt: float

    def __init__(self, lat: float, lon: float, alt: float=0):
        self.lat = lat
        self.lon = lon
        self.alt = alt

    def location(self) -&gt; dronekit.LocationGlobalRelative:
        &#34;&#34;&#34;
        Convert the location held by this `Coordinate` to an object usable by
        `dronekit`
        &#34;&#34;&#34;
        return dronekit.LocationGlobalRelative(self.lat, self.lon, self.alt)

    def ground_distance(self, other) -&gt; float:
        &#34;&#34;&#34;
        Get the ground distance (in meters) between this `Coordinate` and
        another `Coordinate`.

        Makes use of `Coordinate.distance` under the hood
        &#34;&#34;&#34;
        if not isinstance(other, Coordinate):
            raise TypeError()
        
        other = Coordinate(other.lat, other.lon, self.alt)
        return self.distance(other)

    def distance(self, other) -&gt; float:
        &#34;&#34;&#34;
        Get the true distance (in meters) between this `Coordinate` and another
        `Coordinate`. Unline `Coordinate.ground_distance`, this function also
        takes the altitude into account.

        The implementation used here makes use of Haversine Distance -- this
        should be extremely accurate (max err &lt; 3m) for any distances used
        within the scope of the AERPAW program. (&lt;10km)
        &#34;&#34;&#34;
        if not isinstance(other, Coordinate):
            raise TypeError()
        
        # calculation uses haversine distance
        # not the most efficient approx, but as accurate as we need
        d2r = math.pi / 180
        dlon = (other.lon - self.lon) * d2r
        dlat = (other.lat - self.lat) * d2r
        a = math.pow(math.sin(dlat / 2), 2) + math.cos(self.lat*d2r) * math.cos(other.lat*d2r) * math.pow(math.sin(dlon/2), 2)
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
        d = 6367 * c
        return math.hypot(d * 1000, other.alt - self.alt)

    def bearing(self, other) -&gt; float:
        &#34;&#34;&#34;
        Calculate the bearing (angle) between two `Coordinates`, and return it
        in degrees
        &#34;&#34;&#34;
        if not isinstance(other, Coordinate):
            raise TypeError()

        d_lat = other.lat - self.lat
        d_lon = other.lon - self.lon
        bearing = 90 + math.atan2(-d_lat, d_lon) * 57.2957795
        return bearing % 360

    def __add__(self, o):
        north = 0
        east = 0
        alt = 0
        if isinstance(o, VectorNED):
            north = o.north
            east = o.east
            alt = -o.down
        else:
            raise TypeError()

        earth_radius = 6378137.0
        d_lat = north/earth_radius
        d_lon = east/(earth_radius*math.cos(math.pi*self.lat/180))
        new_lat = self.lat + (d_lat * 180/math.pi)
        new_lon = self.lon + (d_lon * 180/math.pi)

        return Coordinate(new_lat, new_lon, self.alt + alt)

    def __sub__(self, o):
        if isinstance(o, VectorNED):
            return self + VectorNED(-o.north, -o.east, -o.down)
        elif isinstance(o, Coordinate):
            # it is, yet again, nontrivial to calculate the distance between coords.
            # here&#39;s one from wikipedia:
            # https://en.wikipedia.org/wiki/Latitude#Length_of_a_degree_of_latitude
            # https://en.wikipedia.org/wiki/Longitude#Length_of_a_degree_of_longitude
            # although since this likely isn&#39;t used a lot, i&#39;m using an approximation
            # https://stackoverflow.com/a/19356480

            lat_mid = (self.lat + o.lat) * math.pi / 360

            d_lat = self.lat - o.lat
            d_lon = self.lon - o.lon

            return VectorNED(d_lat * (111132.954 - 559.822 * math.cos(2 * lat_mid) + 1.175 * math.cos(4 * lat_mid)),
                    d_lon * (111132.954 * math.cos(lat_mid)),
                    o.alt - self.alt)
        else:
            raise TypeError()

# TODO make Waypoint use Coordinates
Waypoint = Tuple[int, float, float, float, int] # command, x, y, z, waypoint_id

def read_from_plan(path: str) -&gt; List[Waypoint]:
    &#34;&#34;&#34;
    Helper function to read a provided .plan file (passed in as `path`) into a
    list of `Waypoint`s that can then be used to run waypoint-based missions.

    An example of this function&#39;s usage can be found under
    `examples/preplanned_trajectory.py`.

    This function has really only been tested with `.plan` files generated by
    QGroundControl. `.plan` internally stores the data as a JSON object, so it
    would be trivial to roll your own generator if needed, but with no
    assertion that this helper would work.

    Use read_from_plan_complete to get a much more generic object containing
    more functionality for each waypoint (ex: speed or time to hold)
    &#34;&#34;&#34;
    waypoints = []
    with open(path) as f:
        data = json.load(f)
    if data[&#34;fileType&#34;] != &#34;Plan&#34;:
        raise Exception(&#34;Wrong file type -- use a .plan file.&#34;)
    for item in data[&#34;mission&#34;][&#34;items&#34;]:
        command = item[&#34;command&#34;]
        if command not in [22, 16, 20]:
            continue
        x, y, z = item[&#34;params&#34;][4:7]
        waypoint_id = item[&#34;doJumpId&#34;]
        waypoints.append((command, x, y, z, waypoint_id))
    return waypoints

def get_location_from_waypoint(waypoint: Waypoint) -&gt; dronekit.LocationGlobalRelative:
    &#34;&#34;&#34;
    Helper to get coordinates in dronekit&#39;s style from a `Waypoint`

    TODO convert/deprecate
    &#34;&#34;&#34;
    return dronekit.LocationGlobalRelative(*waypoint[1:4])

def read_from_plan_complete(path: str):
    &#34;&#34;&#34;
    Helper to read from a .plan file and gather all fields from each waypoint

    This can then be used for more advanced .plan file based missions
    
    Returned data schema subject to change
    &#34;&#34;&#34;
    waypoints = []
    with open(path) as f:
        data = json.load(f)
    if data[&#34;fileType&#34;] != &#34;Plan&#34;:
        raise Exception(&#34;Wrong file type -- use a .plan file.&#34;)
    for item in data[&#34;mission&#34;][&#34;items&#34;]:
        command = item[&#34;command&#34;]
        if command not in [22, 16, 20]:
            continue
        x, y, z = item[&#34;params&#34;][4:7]
        waypoint_id = item[&#34;doJumpId&#34;]
        delay = item[&#34;params&#34;][0]
        waypoints.append({
            &#34;id&#34;: waypoint_id,
            &#34;command&#34;: command,
            &#34;pos&#34;: [x, y, z],
            &#34;wait_for&#34;: delay,
            })
    return waypoints</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="aerpawlib.util.get_location_from_waypoint"><code class="name flex">
<span>def <span class="ident">get_location_from_waypoint</span></span>(<span>waypoint: Tuple[int, float, float, float, int]) ‑> dronekit.LocationGlobalRelative</span>
</code></dt>
<dd>
<div class="desc"><p>Helper to get coordinates in dronekit's style from a <code>Waypoint</code></p>
<p>TODO convert/deprecate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_location_from_waypoint(waypoint: Waypoint) -&gt; dronekit.LocationGlobalRelative:
    &#34;&#34;&#34;
    Helper to get coordinates in dronekit&#39;s style from a `Waypoint`

    TODO convert/deprecate
    &#34;&#34;&#34;
    return dronekit.LocationGlobalRelative(*waypoint[1:4])</code></pre>
</details>
</dd>
<dt id="aerpawlib.util.read_from_plan"><code class="name flex">
<span>def <span class="ident">read_from_plan</span></span>(<span>path: str) ‑> List[Tuple[int, float, float, float, int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to read a provided .plan file (passed in as <code>path</code>) into a
list of <code>Waypoint</code>s that can then be used to run waypoint-based missions.</p>
<p>An example of this function's usage can be found under
<code>examples/preplanned_trajectory.py</code>.</p>
<p>This function has really only been tested with <code>.plan</code> files generated by
QGroundControl. <code>.plan</code> internally stores the data as a JSON object, so it
would be trivial to roll your own generator if needed, but with no
assertion that this helper would work.</p>
<p>Use read_from_plan_complete to get a much more generic object containing
more functionality for each waypoint (ex: speed or time to hold)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_from_plan(path: str) -&gt; List[Waypoint]:
    &#34;&#34;&#34;
    Helper function to read a provided .plan file (passed in as `path`) into a
    list of `Waypoint`s that can then be used to run waypoint-based missions.

    An example of this function&#39;s usage can be found under
    `examples/preplanned_trajectory.py`.

    This function has really only been tested with `.plan` files generated by
    QGroundControl. `.plan` internally stores the data as a JSON object, so it
    would be trivial to roll your own generator if needed, but with no
    assertion that this helper would work.

    Use read_from_plan_complete to get a much more generic object containing
    more functionality for each waypoint (ex: speed or time to hold)
    &#34;&#34;&#34;
    waypoints = []
    with open(path) as f:
        data = json.load(f)
    if data[&#34;fileType&#34;] != &#34;Plan&#34;:
        raise Exception(&#34;Wrong file type -- use a .plan file.&#34;)
    for item in data[&#34;mission&#34;][&#34;items&#34;]:
        command = item[&#34;command&#34;]
        if command not in [22, 16, 20]:
            continue
        x, y, z = item[&#34;params&#34;][4:7]
        waypoint_id = item[&#34;doJumpId&#34;]
        waypoints.append((command, x, y, z, waypoint_id))
    return waypoints</code></pre>
</details>
</dd>
<dt id="aerpawlib.util.read_from_plan_complete"><code class="name flex">
<span>def <span class="ident">read_from_plan_complete</span></span>(<span>path: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper to read from a .plan file and gather all fields from each waypoint</p>
<p>This can then be used for more advanced .plan file based missions</p>
<p>Returned data schema subject to change</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_from_plan_complete(path: str):
    &#34;&#34;&#34;
    Helper to read from a .plan file and gather all fields from each waypoint

    This can then be used for more advanced .plan file based missions
    
    Returned data schema subject to change
    &#34;&#34;&#34;
    waypoints = []
    with open(path) as f:
        data = json.load(f)
    if data[&#34;fileType&#34;] != &#34;Plan&#34;:
        raise Exception(&#34;Wrong file type -- use a .plan file.&#34;)
    for item in data[&#34;mission&#34;][&#34;items&#34;]:
        command = item[&#34;command&#34;]
        if command not in [22, 16, 20]:
            continue
        x, y, z = item[&#34;params&#34;][4:7]
        waypoint_id = item[&#34;doJumpId&#34;]
        delay = item[&#34;params&#34;][0]
        waypoints.append({
            &#34;id&#34;: waypoint_id,
            &#34;command&#34;: command,
            &#34;pos&#34;: [x, y, z],
            &#34;wait_for&#34;: delay,
            })
    return waypoints</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="aerpawlib.util.Coordinate"><code class="flex name class">
<span>class <span class="ident">Coordinate</span></span>
<span>(</span><span>lat: float, lon: float, alt: float = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>An absolute point in space making use of lat, lon, and an altitude (over
the home location of the vehicle). This is more or less equivalent to
<code>dronekit.LocationGlobalRelative</code>, with more functionality added to support
<code><a title="aerpawlib.util.VectorNED" href="#aerpawlib.util.VectorNED">VectorNED</a></code>s.</p>
<p>Reference for the <em>implementations</em> of most of these functions can be found
in the dronekit source or under some of their more specific examples.
Searching for the constants is a pretty good way of finding them.</p>
<p><code>lat</code>/<code>lon</code> should be expressed in <em>degrees</em>, while <code>alt</code> is in <em>meters</em>
(relative to the takeoff/home location)</p>
<p><code><a title="aerpawlib.util.Coordinate" href="#aerpawlib.util.Coordinate">Coordinate</a></code>s can be added or subtracted with <code><a title="aerpawlib.util.VectorNED" href="#aerpawlib.util.VectorNED">VectorNED</a></code>s using Python's
respective operators to calculate a new <code><a title="aerpawlib.util.Coordinate" href="#aerpawlib.util.Coordinate">Coordinate</a></code> relative to the
original. This is particularly useful if you want to implement relative
movement.</p>
<p><code><a title="aerpawlib.util.Coordinate" href="#aerpawlib.util.Coordinate">Coordinate</a></code>s can be subtracted from each other using Python's subtraction
operator to calculate the vector difference between them, which is returned
as a <code><a title="aerpawlib.util.VectorNED" href="#aerpawlib.util.VectorNED">VectorNED</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Coordinate:
    &#34;&#34;&#34;
    An absolute point in space making use of lat, lon, and an altitude (over
    the home location of the vehicle). This is more or less equivalent to
    `dronekit.LocationGlobalRelative`, with more functionality added to support
    `VectorNED`s.

    Reference for the *implementations* of most of these functions can be found
    in the dronekit source or under some of their more specific examples.
    Searching for the constants is a pretty good way of finding them.

    `lat`/`lon` should be expressed in *degrees*, while `alt` is in *meters*
    (relative to the takeoff/home location)

    `Coordinate`s can be added or subtracted with `VectorNED`s using Python&#39;s
    respective operators to calculate a new `Coordinate` relative to the
    original. This is particularly useful if you want to implement relative
    movement.

    `Coordinate`s can be subtracted from each other using Python&#39;s subtraction
    operator to calculate the vector difference between them, which is returned
    as a `VectorNED`
    &#34;&#34;&#34;

    lat: float
    lon: float
    alt: float

    def __init__(self, lat: float, lon: float, alt: float=0):
        self.lat = lat
        self.lon = lon
        self.alt = alt

    def location(self) -&gt; dronekit.LocationGlobalRelative:
        &#34;&#34;&#34;
        Convert the location held by this `Coordinate` to an object usable by
        `dronekit`
        &#34;&#34;&#34;
        return dronekit.LocationGlobalRelative(self.lat, self.lon, self.alt)

    def ground_distance(self, other) -&gt; float:
        &#34;&#34;&#34;
        Get the ground distance (in meters) between this `Coordinate` and
        another `Coordinate`.

        Makes use of `Coordinate.distance` under the hood
        &#34;&#34;&#34;
        if not isinstance(other, Coordinate):
            raise TypeError()
        
        other = Coordinate(other.lat, other.lon, self.alt)
        return self.distance(other)

    def distance(self, other) -&gt; float:
        &#34;&#34;&#34;
        Get the true distance (in meters) between this `Coordinate` and another
        `Coordinate`. Unline `Coordinate.ground_distance`, this function also
        takes the altitude into account.

        The implementation used here makes use of Haversine Distance -- this
        should be extremely accurate (max err &lt; 3m) for any distances used
        within the scope of the AERPAW program. (&lt;10km)
        &#34;&#34;&#34;
        if not isinstance(other, Coordinate):
            raise TypeError()
        
        # calculation uses haversine distance
        # not the most efficient approx, but as accurate as we need
        d2r = math.pi / 180
        dlon = (other.lon - self.lon) * d2r
        dlat = (other.lat - self.lat) * d2r
        a = math.pow(math.sin(dlat / 2), 2) + math.cos(self.lat*d2r) * math.cos(other.lat*d2r) * math.pow(math.sin(dlon/2), 2)
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
        d = 6367 * c
        return math.hypot(d * 1000, other.alt - self.alt)

    def bearing(self, other) -&gt; float:
        &#34;&#34;&#34;
        Calculate the bearing (angle) between two `Coordinates`, and return it
        in degrees
        &#34;&#34;&#34;
        if not isinstance(other, Coordinate):
            raise TypeError()

        d_lat = other.lat - self.lat
        d_lon = other.lon - self.lon
        bearing = 90 + math.atan2(-d_lat, d_lon) * 57.2957795
        return bearing % 360

    def __add__(self, o):
        north = 0
        east = 0
        alt = 0
        if isinstance(o, VectorNED):
            north = o.north
            east = o.east
            alt = -o.down
        else:
            raise TypeError()

        earth_radius = 6378137.0
        d_lat = north/earth_radius
        d_lon = east/(earth_radius*math.cos(math.pi*self.lat/180))
        new_lat = self.lat + (d_lat * 180/math.pi)
        new_lon = self.lon + (d_lon * 180/math.pi)

        return Coordinate(new_lat, new_lon, self.alt + alt)

    def __sub__(self, o):
        if isinstance(o, VectorNED):
            return self + VectorNED(-o.north, -o.east, -o.down)
        elif isinstance(o, Coordinate):
            # it is, yet again, nontrivial to calculate the distance between coords.
            # here&#39;s one from wikipedia:
            # https://en.wikipedia.org/wiki/Latitude#Length_of_a_degree_of_latitude
            # https://en.wikipedia.org/wiki/Longitude#Length_of_a_degree_of_longitude
            # although since this likely isn&#39;t used a lot, i&#39;m using an approximation
            # https://stackoverflow.com/a/19356480

            lat_mid = (self.lat + o.lat) * math.pi / 360

            d_lat = self.lat - o.lat
            d_lon = self.lon - o.lon

            return VectorNED(d_lat * (111132.954 - 559.822 * math.cos(2 * lat_mid) + 1.175 * math.cos(4 * lat_mid)),
                    d_lon * (111132.954 * math.cos(lat_mid)),
                    o.alt - self.alt)
        else:
            raise TypeError()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="aerpawlib.util.Coordinate.alt"><code class="name">var <span class="ident">alt</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aerpawlib.util.Coordinate.lat"><code class="name">var <span class="ident">lat</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aerpawlib.util.Coordinate.lon"><code class="name">var <span class="ident">lon</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="aerpawlib.util.Coordinate.bearing"><code class="name flex">
<span>def <span class="ident">bearing</span></span>(<span>self, other) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the bearing (angle) between two <code>Coordinates</code>, and return it
in degrees</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bearing(self, other) -&gt; float:
    &#34;&#34;&#34;
    Calculate the bearing (angle) between two `Coordinates`, and return it
    in degrees
    &#34;&#34;&#34;
    if not isinstance(other, Coordinate):
        raise TypeError()

    d_lat = other.lat - self.lat
    d_lon = other.lon - self.lon
    bearing = 90 + math.atan2(-d_lat, d_lon) * 57.2957795
    return bearing % 360</code></pre>
</details>
</dd>
<dt id="aerpawlib.util.Coordinate.distance"><code class="name flex">
<span>def <span class="ident">distance</span></span>(<span>self, other) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Get the true distance (in meters) between this <code><a title="aerpawlib.util.Coordinate" href="#aerpawlib.util.Coordinate">Coordinate</a></code> and another
<code><a title="aerpawlib.util.Coordinate" href="#aerpawlib.util.Coordinate">Coordinate</a></code>. Unline <code><a title="aerpawlib.util.Coordinate.ground_distance" href="#aerpawlib.util.Coordinate.ground_distance">Coordinate.ground_distance()</a></code>, this function also
takes the altitude into account.</p>
<p>The implementation used here makes use of Haversine Distance &ndash; this
should be extremely accurate (max err &lt; 3m) for any distances used
within the scope of the AERPAW program. (&lt;10km)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance(self, other) -&gt; float:
    &#34;&#34;&#34;
    Get the true distance (in meters) between this `Coordinate` and another
    `Coordinate`. Unline `Coordinate.ground_distance`, this function also
    takes the altitude into account.

    The implementation used here makes use of Haversine Distance -- this
    should be extremely accurate (max err &lt; 3m) for any distances used
    within the scope of the AERPAW program. (&lt;10km)
    &#34;&#34;&#34;
    if not isinstance(other, Coordinate):
        raise TypeError()
    
    # calculation uses haversine distance
    # not the most efficient approx, but as accurate as we need
    d2r = math.pi / 180
    dlon = (other.lon - self.lon) * d2r
    dlat = (other.lat - self.lat) * d2r
    a = math.pow(math.sin(dlat / 2), 2) + math.cos(self.lat*d2r) * math.cos(other.lat*d2r) * math.pow(math.sin(dlon/2), 2)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
    d = 6367 * c
    return math.hypot(d * 1000, other.alt - self.alt)</code></pre>
</details>
</dd>
<dt id="aerpawlib.util.Coordinate.ground_distance"><code class="name flex">
<span>def <span class="ident">ground_distance</span></span>(<span>self, other) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Get the ground distance (in meters) between this <code><a title="aerpawlib.util.Coordinate" href="#aerpawlib.util.Coordinate">Coordinate</a></code> and
another <code><a title="aerpawlib.util.Coordinate" href="#aerpawlib.util.Coordinate">Coordinate</a></code>.</p>
<p>Makes use of <code><a title="aerpawlib.util.Coordinate.distance" href="#aerpawlib.util.Coordinate.distance">Coordinate.distance()</a></code> under the hood</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ground_distance(self, other) -&gt; float:
    &#34;&#34;&#34;
    Get the ground distance (in meters) between this `Coordinate` and
    another `Coordinate`.

    Makes use of `Coordinate.distance` under the hood
    &#34;&#34;&#34;
    if not isinstance(other, Coordinate):
        raise TypeError()
    
    other = Coordinate(other.lat, other.lon, self.alt)
    return self.distance(other)</code></pre>
</details>
</dd>
<dt id="aerpawlib.util.Coordinate.location"><code class="name flex">
<span>def <span class="ident">location</span></span>(<span>self) ‑> dronekit.LocationGlobalRelative</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the location held by this <code><a title="aerpawlib.util.Coordinate" href="#aerpawlib.util.Coordinate">Coordinate</a></code> to an object usable by
<code>dronekit</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def location(self) -&gt; dronekit.LocationGlobalRelative:
    &#34;&#34;&#34;
    Convert the location held by this `Coordinate` to an object usable by
    `dronekit`
    &#34;&#34;&#34;
    return dronekit.LocationGlobalRelative(self.lat, self.lon, self.alt)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aerpawlib.util.VectorNED"><code class="flex name class">
<span>class <span class="ident">VectorNED</span></span>
<span>(</span><span>north: float, east: float, down: float = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Representation of a difference between two coordinates (used for expressing
relative motion). Makes use of NED (north, east, down) scheme.</p>
<p>Units are expressed in meters</p>
<p>NOTE: Something similar to this may or may not be adopted into dronkit at
some point in the future. There are plans on their GH page, at least.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VectorNED:
    &#34;&#34;&#34;
    Representation of a difference between two coordinates (used for expressing
    relative motion). Makes use of NED (north, east, down) scheme.

    Units are expressed in meters

    NOTE: Something similar to this may or may not be adopted into dronkit at
    some point in the future. There are plans on their GH page, at least.
    &#34;&#34;&#34;

    north: float
    east: float
    down: float

    def __init__(self, north: float, east: float, down: float=0):
        self.north = north
        self.east = east
        self.down = down

    def rotate_by_angle(self, angle: float):
        &#34;&#34;&#34;
        Transform this VectorNED and rotate it by a certain angle, provided in
        degrees.

        ex: VectorNED(1, 0, 0).rotate_by_angle(90) -&gt; VectorNed(0, -1, 0)
        ex: VectorNED(1, 0, 0).rotate_by_angle(45) -&gt; VectorNed(0.707, -0.707, 0)
        &#34;&#34;&#34;
        rads = angle / 180 * math.pi
        
        east = self.east * math.cos(rads) - self.north * math.sin(rads)
        north = self.east * math.sin(rads) + self.north * math.cos(rads)
        
        return VectorNED(north, east, self.down)

    def cross_product(self, o):
        &#34;&#34;&#34;
        find the cross product of this and the other vector (this x o)
        &#34;&#34;&#34;
        if not isinstance(o, VectorNED):
            raise TypeError()
        return VectorNED(
                self.east * o.down + self.down * o.east,
                self.down * o.north - self.north * o.down,
                self.north * o.east - self.east * o.north
                )

    def hypot(self, ignore_down: bool=False):
        &#34;&#34;&#34;
        find the distance of this VectorNED, optionally ignoring any changes in
        height
        &#34;&#34;&#34;
        if ignore_down:
            return math.hypot(self.north, self.east)
        else:
            return math.hypot(self.north, self.east, self.down)

    def __add__(self, o):
        if not isinstance(o, VectorNED):
            raise TypeError()
        return VectorNED(self.north + o.north,
                self.east + o.east,
                self.down + o.down)

    def __sub__(self, o):
        if not isinstance(o, VectorNED):
            raise TypeError()
        return VectorNED(self.north - o.north,
                self.east - o.east,
                self.down - o.down)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="aerpawlib.util.VectorNED.down"><code class="name">var <span class="ident">down</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aerpawlib.util.VectorNED.east"><code class="name">var <span class="ident">east</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aerpawlib.util.VectorNED.north"><code class="name">var <span class="ident">north</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="aerpawlib.util.VectorNED.cross_product"><code class="name flex">
<span>def <span class="ident">cross_product</span></span>(<span>self, o)</span>
</code></dt>
<dd>
<div class="desc"><p>find the cross product of this and the other vector (this x o)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cross_product(self, o):
    &#34;&#34;&#34;
    find the cross product of this and the other vector (this x o)
    &#34;&#34;&#34;
    if not isinstance(o, VectorNED):
        raise TypeError()
    return VectorNED(
            self.east * o.down + self.down * o.east,
            self.down * o.north - self.north * o.down,
            self.north * o.east - self.east * o.north
            )</code></pre>
</details>
</dd>
<dt id="aerpawlib.util.VectorNED.hypot"><code class="name flex">
<span>def <span class="ident">hypot</span></span>(<span>self, ignore_down: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>find the distance of this VectorNED, optionally ignoring any changes in
height</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hypot(self, ignore_down: bool=False):
    &#34;&#34;&#34;
    find the distance of this VectorNED, optionally ignoring any changes in
    height
    &#34;&#34;&#34;
    if ignore_down:
        return math.hypot(self.north, self.east)
    else:
        return math.hypot(self.north, self.east, self.down)</code></pre>
</details>
</dd>
<dt id="aerpawlib.util.VectorNED.rotate_by_angle"><code class="name flex">
<span>def <span class="ident">rotate_by_angle</span></span>(<span>self, angle: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Transform this VectorNED and rotate it by a certain angle, provided in
degrees.</p>
<p>ex: VectorNED(1, 0, 0).rotate_by_angle(90) -&gt; VectorNed(0, -1, 0)
ex: VectorNED(1, 0, 0).rotate_by_angle(45) -&gt; VectorNed(0.707, -0.707, 0)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_by_angle(self, angle: float):
    &#34;&#34;&#34;
    Transform this VectorNED and rotate it by a certain angle, provided in
    degrees.

    ex: VectorNED(1, 0, 0).rotate_by_angle(90) -&gt; VectorNed(0, -1, 0)
    ex: VectorNED(1, 0, 0).rotate_by_angle(45) -&gt; VectorNed(0.707, -0.707, 0)
    &#34;&#34;&#34;
    rads = angle / 180 * math.pi
    
    east = self.east * math.cos(rads) - self.north * math.sin(rads)
    north = self.east * math.sin(rads) + self.north * math.cos(rads)
    
    return VectorNED(north, east, self.down)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="aerpawlib" href="index.html">aerpawlib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="aerpawlib.util.get_location_from_waypoint" href="#aerpawlib.util.get_location_from_waypoint">get_location_from_waypoint</a></code></li>
<li><code><a title="aerpawlib.util.read_from_plan" href="#aerpawlib.util.read_from_plan">read_from_plan</a></code></li>
<li><code><a title="aerpawlib.util.read_from_plan_complete" href="#aerpawlib.util.read_from_plan_complete">read_from_plan_complete</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="aerpawlib.util.Coordinate" href="#aerpawlib.util.Coordinate">Coordinate</a></code></h4>
<ul class="two-column">
<li><code><a title="aerpawlib.util.Coordinate.alt" href="#aerpawlib.util.Coordinate.alt">alt</a></code></li>
<li><code><a title="aerpawlib.util.Coordinate.bearing" href="#aerpawlib.util.Coordinate.bearing">bearing</a></code></li>
<li><code><a title="aerpawlib.util.Coordinate.distance" href="#aerpawlib.util.Coordinate.distance">distance</a></code></li>
<li><code><a title="aerpawlib.util.Coordinate.ground_distance" href="#aerpawlib.util.Coordinate.ground_distance">ground_distance</a></code></li>
<li><code><a title="aerpawlib.util.Coordinate.lat" href="#aerpawlib.util.Coordinate.lat">lat</a></code></li>
<li><code><a title="aerpawlib.util.Coordinate.location" href="#aerpawlib.util.Coordinate.location">location</a></code></li>
<li><code><a title="aerpawlib.util.Coordinate.lon" href="#aerpawlib.util.Coordinate.lon">lon</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aerpawlib.util.VectorNED" href="#aerpawlib.util.VectorNED">VectorNED</a></code></h4>
<ul class="two-column">
<li><code><a title="aerpawlib.util.VectorNED.cross_product" href="#aerpawlib.util.VectorNED.cross_product">cross_product</a></code></li>
<li><code><a title="aerpawlib.util.VectorNED.down" href="#aerpawlib.util.VectorNED.down">down</a></code></li>
<li><code><a title="aerpawlib.util.VectorNED.east" href="#aerpawlib.util.VectorNED.east">east</a></code></li>
<li><code><a title="aerpawlib.util.VectorNED.hypot" href="#aerpawlib.util.VectorNED.hypot">hypot</a></code></li>
<li><code><a title="aerpawlib.util.VectorNED.north" href="#aerpawlib.util.VectorNED.north">north</a></code></li>
<li><code><a title="aerpawlib.util.VectorNED.rotate_by_angle" href="#aerpawlib.util.VectorNED.rotate_by_angle">rotate_by_angle</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>